{
    "contents" : "################################################################################################################################################\n\n                                 # Author: Cornelia Oedekoven \n                                 \n                                 # Centre for Research into Ecological and Environmental Modelling\n                                 # University of St Andrews, St Andrews, Scotland\n                                 # cornelia@mcs.st-and.ac.uk \n                                 \n                                 # R code for RJMCMC algorithm for analysing covey data (repeated point transects with exact distance data)\n                                 \n                                 # Additional functions are given to adapt analysis to line transect and/or interval distance data \n                                 \n\n################################################################################################################################################\n\n# Data format required:\n\n# for the detection function model L_y(\\bmath{\\theta}) (eqn (3))\n# matrix covey.d: a n*6 matrix  (n = total number of detections, 6 columns: id, distance, site, year, type, state)\ncovey.d<-covey2[which(is.na(covey2$Distance)==F),]\nlength.d<-length(covey.d$Distance)\n\n# for the density model L_n(\\bmath{\\beta}|\\bmath{\\theta}) (eqn (6))\n# matrix n.jpr: a j*max(Tj) matrix with n_jpr (counts at site j, point p, visit r (Tj is a vector of numbers of measurements in the jth group)\n# matrices with covariates: j*max(Tj) matrix with observed covariate values at site j, point p, visit r: Year, Type, Day (Julian day) and State\n\n# number of observations for each site\nTj<-array(NA,j)\nfor (i in 1:j){\nTj[i]<-length(count.data$Pair2[glm.data$Pair2==pair[i]])\n}\n\nsite<-sort(unique(count.data$Site))\nj<-length(site)\nyears<-sort(unique(count.data$Year))\nStates<-sort(unique(count.data$State))\n\n# matrix that will hold the counts n.jpr for each site (1 row per site)\nY<-matrix(NA,j,max(Tj))\n\n# matrix that will hold the values for Year (1 for 2006, 2 for 2007, 3 for 2008): factor covariate with 2 levels\nYear<-matrix(NA,j,max(Tj))\n\n# matrix that will hold a 0 or 1 depending on whether Type = CONTROL or TREAT, respectively\nType<-matrix(NA,j,max(Tj))\n\n# matrix that will hold the values for Julian day\nDay<-matrix(NA,j,max(Tj))\n\n# matrix that will hold the values for State\nState<-matrix(NA,j,max(Tj))\n\n# filling in the above values from\nfor (i in 1:j){\n\nx<-which(count.data$Site==site[i])\nl<-length(count.data$Count[x])\ny<-count.data$Count[x]\n    for (k in 1:l){\n\n      Y[i,k]<-y[k]\n      Year[i,k]<-ifelse(count.data$Year[x[k]]==2006,1,{ifelse(count.data$Year[x[k]]==2007,2,3)})\n      Type[i,k]<-ifelse(count.data$Type[x[k]]==\"TREAT\",1,0)\n      Day[i,k]<-count.data$jd[x[k]]\n      State[i,k]<-which(States==count.data$State[x[k]])\n      }\n     }\nsum(Y[which(is.na(Y)==F)])\n#[1] 2545\n\n########################################  set initial values ##############\n\n# global hazard-rate model with scale and shape for L_y(\\bmath{\\theta}) (eqn (3)\nscale0<-130\nshape0<-2.5\n\n#  count model parameters: intercept and random effect standard deviation for L_n(\\bmath{\\beta}|\\bmath{\\theta}) (eqn (6))\nint0<- -13\nstd.ran0<-1\n\n# the random effect coefficients b_j\nb0<-rnorm(j,0,std.ran0)\n\n\n#########################################################################\n# setting up the matrices that will contain the paramter values;\n\n# number of iterations\nnt<-100000\n\n# holds the values for detection function parameters for each iteration\n# 15 colums due to 15 parameters in full model: hazard-rate det fct with covariates: year, type and state\ndet.param<-matrix(NA,nt+1,15)\n\n# for an intercept only model:\ndet.param[1,]<-c(scale0, shape0, rep(0,13))\n\n# holds the model id number for detection function for each iteration, \ndet.model<-matrix(NA,nt+1,1)            # refers to det.list\n\n# the matrix that will keep the parameter values for the density model\ncount.param<-matrix(NA,nt+1,(j+18))     \n\n# filling in the initial values\ncount.param[1,1:(j+18)]<-c(int0,rep(0,16),std.ran0,b0)\n\n# holds the model id number for density model for each iteration\ncount.model<-matrix(NA,nt+1,1)          # refers to count.list\n\n############# proposal distributions\n# proposal distributions for detection function parameters:\n\n# 1. for main analysis and prior sensitivity analysis\ndet.prop.mean<-c(138.60, 3.00, 0.11, -0.15, 0.50, 0.42, 0.21, 0.70, 0.67, 0.64, 0.69, 0.61, 0.66, 0.03, 0.47)\ndet.prop.sd<-c(1.41, 0.84, rep(0.1,13))\n\n# proposal distribution for the fixed effect density model parameters\n# 1. for covey data\ncount.prop.mean<-c(-13.06, 0, 0.16, 0.08, 0.42, -0.01, 0, -0.71, -0.49, -1.16, -0.41, 0.01, -0.38, -1.36, 0.07, -1.05, 1.77)\ncount.prop.sd<-c(0.30, 0, 0.05, 0.05, 0.10,  0.01, 0, 0.24, 0.24, 0.23, 0.22, 0.20, 0.22, 0.23, 0.22, 0.23, 0.21)\n\n################## picking the first model for detection function\ndet.model[1,1]<-5   # global hazard-rate: \\bmath{\\theta} = \\{\\sigma,\\tau\\}\ncur.dmod<-det.model[1,1]\n# holds the current det function parameters (vector \\bmath{\\theta}^t_m for model m)\nrj.cursigs<-det.param[1,]\n\n\n################## picking the first model for density model\n# there are 16 models (all of them include random effect for Pair2):\n# to pick the first model:\ncount.model[1]<-1          # intercept and random effect only model \\bmath{\\beta}=\\{\\beta_0,\\sigma_b^2\\}\ncur.mod<-1\n# holds the parameter values for the current density model (vector \\bmath{\\beta}^t for model m)\nrj.curparam<-count.param[1,1:(j+18)]\n\n# model identifier for detection function, model number in rows, parameters (y/n) in columns\ndet.list<-matrix(NA, 8, 15)\ncolnames(det.list)<-c(\"sig\",\"sha\",\"yea6\",\"yea7\",\"typ\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\",\"sta\")\ndet.list[1,]<-c(1,1,1,1,0,rep(1,10))     # mcds with state and year\ndet.list[2,]<-c(1,1,0,0,1,rep(0,10))     # mcds with type\ndet.list[3,]<-c(1,1,0,0,0,rep(1,10))     # mcds with state\ndet.list[4,]<-c(1,1,0,0,1,rep(1,10))     # mcds with state and type\ndet.list[5,]<-c(1,1,rep(0,13))           # global hazard rate model\ndet.list[6,]<-c(1,1,rep(1,13))           # mcds with state year and type\ndet.list[7,]<-c(1,1,1,1,0,rep(0,10))     # mcds with year\ndet.list[8,]<-c(1,1,1,1,1,rep(0,10))     # mcds with year and type\n\n# model identifier for density model, model number in rows, parameters (y/n) in columns\ncount.list<-matrix(0,16,17)\ndimnames(count.list)[[2]]<-c(\"int\",\"year6\",\"year7\",\"year8\",\"typ\",\"day\",\"sta1\",\"sta2\",\"sta3\",\"sta4\",\"sta5\",\"sta6\",\"sta7\",\"sta8\",\"sta9\",\"sta10\",\"sta11\")\ncount.list[1,c(1)]<-1\ncount.list[2,c(1,3:4)]<-1\ncount.list[3,c(1,5)]<-1\ncount.list[4,c(1,6)]<-1\ncount.list[5,c(1,3,4,5)]<-1\ncount.list[6,c(1,3,4,5,6)]<-1\ncount.list[7,c(1,3,4,6)]<-1\ncount.list[8,c(1,5,6)]<-1\ncount.list[9,c(1,8:17)]<-1\ncount.list[10,c(1,3,4,8:17)]<-1\ncount.list[11,c(1,5,8:17)]<-1\ncount.list[12,c(1,5,6,8:17)]<-1\ncount.list[13,c(1,3,4,5,8:17)]<-1\ncount.list[14,c(1,3,4,6,8:17)]<-1\ncount.list[15,c(1,3,4,5,6,8:17)]<-1\ncount.list[16,c(1,6,8:17)]<-1\n\n################################# Likelihood functions ################################################\n\n# hazard-rate function for point transects: \\pi(y) * g(y|\\bmath{\\theta}) from eqn (2)\nf.haz.function<-function(dis,sigma,shape) {\n  f <- 2*pi*dis*(1-exp(-(dis/sigma)^(-shape)))\n  return(f)\n  }\n\n############################### the priors ###########################################################\n\n### detection function parameters\n# for scale intercept\nl.prior.sig<-function(sigm){\nlog.u.sig<-array(NA,length(sigm))\nfor (k in 1:length(sigm)){\nlog.u.sig[k]<-log(dunif(sigm[k],1,100000))                                \n }\nreturn(sum(log.u.sig))}\n\n# for shape\nl.prior.sha<-function(shap){\nlog.u.sha<-array(NA,length(shap))\nfor (k in 1:length(shap)){\nlog.u<-log(dunif(shap[k],1,20))\nifelse(abs(log.u)==Inf,log.u.sha[k]<--100000,log.u.sha[k]<-log.u)}\nreturn(sum(log.u.sha))}\n\n# for scale coefficients\n# for type covariate\nl.prior.coeftyp<-function(coefsig){\nlcs<-length(coefsig)\nlog.u.coefsig<-array(NA,lcs)\nfor (k in 1:lcs){\nlog.u<-log(dunif(coefsig[k],-3,3))          \nifelse(abs(log.u)==Inf,log.u.coefsig[k]<- -100000,log.u.coefsig[k]<-log.u)}\nreturn(sum(log.u.coefsig))}\n\nl.prior.coef<-function(coefsig){\nlcs<-length(coefsig)\nlog.u.coefsig<-array(NA,lcs)\nfor (k in 1:lcs){\nlog.u<-log(dunif(coefsig[k],-2.5,2.5))\nifelse(abs(log.u)==Inf,log.u.coefsig[k]<- -100000,log.u.coefsig[k]<-log.u)}\nreturn(sum(log.u.coefsig))}\n\n### the priors for density model parameters\n# intercept\nl.prior.int<-function(int){\nl.u.int<-log(dunif(int,-20,-7))\nreturn(l.u.int)}\n\n# year\nl.prior.year<-function(yea){\nl.u.yea1<-log(dunif(yea[1],-1,1));\nl.u.yea2<-log(dunif(yea[2],-1,1));\nl.u.yea<-sum(l.u.yea1,l.u.yea2)\nif(abs(l.u.yea)==Inf){l.u.yea<- -100000}\nreturn(l.u.yea)}\n\n# 1 year\nl.prior.year1<-function(yea){\nl.u.yea<-log(dunif(yea[1],-1,1));\nif(abs(l.u.yea)==Inf){l.u.yea<- -100000}\nreturn(l.u.yea)}\n\n# type\nl.prior.type<-function(typ){\nl.u.typ<-log(dunif(typ,0,3))\nif(abs(l.u.typ)==Inf){l.u.typ<- -100000}\nreturn(l.u.typ)}\n\n# day\nl.prior.day<-function(day){\nl.u.day<-log(dunif(day,-0.1,0.1))\nreturn(l.u.day)}\n\n# state\nl.prior.st<-function(st){\n# last state is always zero (absorbed in intercept) so omitted\nl.u.st1<-log(dunif(st[1],-3,3))\nl.u.st2<-log(dunif(st[2],-3,3))\nl.u.st3<-log(dunif(st[3],-3,3))\nl.u.st4<-log(dunif(st[4],-3,3))\nl.u.st5<-log(dunif(st[5],-3,3))\nl.u.st6<-log(dunif(st[6],-3,3))\nl.u.st7<-log(dunif(st[7],-3,3))\nl.u.st8<-log(dunif(st[8],-3,3))\nl.u.st9<-log(dunif(st[9],-3,3))\nl.u.st10<-log(dunif(st[10],-3,3))\nlog.u.st<-sum(l.u.st1,l.u.st2,l.u.st3,l.u.st4,l.u.st5,l.u.st6,l.u.st7,l.u.st8,l.u.st9,l.u.st10)\nif(abs(log.u.st)==Inf){log.u.st<- -100000 }\nreturn(log.u.st)}\n\n#  1 state\nl.prior.1st<-function(st){\nlog.u.st<-log(dunif(st,-3,3))\nif(abs(log.u.st)==Inf){log.u.st<- -100000}\nreturn(log.u.st)}\n\n# random effect standard deviation (std.ran)\nl.prior.std.ran<-function(std.ran){\nl.u.std.ran<-log(dunif(std.ran,0,2))\nreturn(l.u.std.ran)}\n\n\n########################## the posterior conditional distribution functions ######################\n\n### integrated likelihood L_{n,y}(\\bmath{\\beta},\\bmath{\\theta}} from eqn (1)\n# p combines all parameters \\bmath{\\theta}\\bmath{\\beta} and bj from eqns (1) - (7)\nlog.lik.fct<-function(p){\nsig1<-p[1]               # det fct: scale intercept\nsha2<-p[2]               # det fct: shape\nsig.y<-c(p[3:4],0)       # det fct: year 2006,2007,2008 coef\nsig.t<-p[5]              # det fct: type level CONTROL coef\nsig.st<-c(p[6:15],0)     # det fct: states coef\nint<-p[16]               # density intercept\nyea<-p[17:19]            # density year 2006,2007,2008\ntyp<-p[20]               # density type level TREAT\nday<-p[21]               # density day coef\nst<-p[22:32]             # density state coef\nstd.ran<-p[33]           # density random effect standard deviation\nb<-p[34:(j+33)]          # random effect coefficients\n\n# 1. calculate the different scale parameters as function of parameters\nsig.msyt<-matrix(NA,11,6)      # 11 states (rows), 3 years * 2 type levels (CONTROL,TREAT) (columns)\nefa<-matrix(NA,11,6)\n\n  for (strat in 1:11){        \n   for (ty in 4:6){\n   sig.msyt[strat,ty]<-sig1*exp(sig.st[strat]+ sig.y[ty-3])}}\n\n   for (strat in 1:11){\n    for (ty in 1:3){\n    sig.msyt[strat,ty]<-sig.msyt[strat,ty+3]*exp(sig.t)}}\n\n# 2. calculate the different effective areas as a function of covariates (using the scales from sig.msyt)\n   for (strat in 1:11){\n    for (ty in 1:6){\n    efa[strat,ty]<-integrate(f.haz.function,0,500,sig.msyt[strat,ty],sha2)$value}}\n\n# 3. calculate the f_e for each detection for det model likelihood component L_y(\\bmath{\\theta}) (eqn (3): exact distance data)\nfe<-array(NA,length.d)\nfor (im in 1:length.d){\n  ist<-which(states==covey.d$State[im])\n  yst<-which(years==covey.d$Year[im])\n  ifelse(covey.d$Type[im]==\"CONTROL\",multi<-0,multi<-3)\n  norm.const<-efa[ist,multi+yst]    # normalising constant from denominator in eqn (2) equals the effective area for a given scale and shape parameter\n  fe[im]<-log(f.haz.function(covey.d$Distance[im],sig.msyt[ist,multi+yst],sha2)/norm.const)\n    }\n\n# 4. arrange the offset from the current det model in a matrix for each observed count n.jpr in matrix Y (the \\nu_{jpr} from eqn(6)):\noffset<-matrix(NA,j,max(Tj))\nfor (is in 1:j){\n for (ts in 1:Tj[is]){\nifelse(Type[is,ts]==0,multi<-0,multi<-3)\noffset[is,ts]<-efa[State[is,1],Year[is,ts]+multi]\n}}\n\n# 5. model L_n(\\bmath{\\beta}|\\bmath{\\theta}) from eqn (7)\n l.pois.y<-matrix(NA,j,max(Tj))  # matrix that will hold the Poisson likelihood for each observation n_jpr\n l.b.norm<-array(NA,j)           # vector that will hold the normal density for each random effect coefficients b_j\n lambda<-matrix(NA,j,max(Tj))    # matrix for storing the lambda_jpr from eqn (6)\n   # for each site \n   for (ik in 1:j){\n        # for each observation at that site\n        for (k in 1:Tj[ik]){\n        lambda[ik,k]<-exp(int + yea[Year[ik,k]] + Type[ik,k]*typ + day*Day[ik,k] + st[State[ik,k]] + b[ik] + log(offset[ik,k]))\n        l.pois.y[ik,k]<-log(dpois(Y[ik,k],lambda[ik,k]))    # Poisson log-likelihood for each observation n_jpr in Y\n        }\n   l.b.norm[ik]<-log(dnorm(b[ik],0,std.ran))                # log of normal density for b_j\n   }\n\n   post<-sum(fe) + sum(l.pois.y[which(is.na(l.pois.y)==F)]) + sum(l.b.norm)\n   return(post)\n }\n\n\n################################# other function you will need\n# this function matches a string of numbers against rows a matrix\n# and will return the row number of matrix that matches the string exactly\nmatch.function<-function(xmod,model.matrix){\nis.match.or.not<-array(NA,length(model.matrix[,1]))\nfor (i in 1:length(model.matrix[,1])){\nis.match.or.not[i]<-sum(xmod==model.matrix[i,])}\nresult<-which(is.match.or.not==length(model.matrix[1,]))\nreturn(result)\n}\n\ni=2\n\n#################################  the RJMCMC algorithm ######################################\n# nt is the number of iterations and is set above\n# row 1 is filled in with initial values for parameters and models\nfor (i in 2:nt){\nprint(i)\n\n##################### RJ step : sequential proposals to add or delete covariates depending on whether they are in the model or not #####\n# all models are considered equally likely, i.e. P(m|m') = P(m'|m) for all m' and m\n\n############## the detection function  ########################\n\n      # the current model\n      cur.dmod<-det.model[i-1]\n      curpa<-det.list[cur.dmod,]\n      # setting the parameters for the new model equal to the current model\n      newpa<-curpa\n      rj.newsigs<-rj.cursigs\n\n      # going through the list of coefficients to check whether to add or remove one\n      # year coefficient\n      ifelse(curpa[3]==0,{        # if year is not currently in the model, propose to add it\n      newpa[3:4]<-1\n      rj.newsigs[3:4]<-rnorm(2,det.prop.mean[3:4],det.prop.sd[3:4])   # draw random samples from proposal distributions\n      # the numerator of eqn (11)\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam))+ l.prior.coef(rj.newsigs[3:4])\n      # the denominator of eqn (11)\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam))+sum(log(dnorm(rj.newsigs[3:4],msyt.prop.mean[3:4],msyt.prop.sd[3:4])))\n        } ,\n        {\n      newpa[3:4]<-0               # if year is in the current model, propose to delete it\n      rj.newsigs[3:4]<-0\n      # the numerator of eqn (11)\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam)) + sum(log(dnorm(rj.cursigs[3:4],msyt.prop.mean[3:4],msyt.prop.sd[3:4])))\n      # the denominator of eqn (11)\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam))+ l.prior.coef(rj.cursigs[3:4])\n        })\n                   A<-min(1,exp(num-den))                   # proposed move is accepted with probability A\n                   V<-runif(1)\n                    ifelse(V<=A,{                           # if move is accepted change current values to new values\n                       rj.cursigs<-rj.newsigs               \n                       curpa<-newpa},\n                                {                             \n                       rj.newsigs<-rj.cursigs               # if move is rejected, reset everything to current\n                       newpa<-curpa\n                                })\n\n      # type coefficient\n      ifelse(curpa[5]==0,{        # if type is not in the current model, propose to add it\n      newpa[5]<-1\n      rj.newsigs[5]<-rnorm(1,det.prop.mean[5],det.prop.sd[5])  # draw a random sample from proposal distribution\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam))+ l.prior.coeftyp(rj.newsigs[5])\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam))+ sum(log(dnorm(rj.newsigs[5],msyt.prop.mean[5],msyt.prop.sd[5])))\n        } ,\n        {\n      newpa[5]<-0                 # if type is in the current model, propose to delete it\n      rj.newsigs[5]<-0\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam))+ sum(log(dnorm(rj.cursigs[5],msyt.prop.mean[5],msyt.prop.sd[5])))\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam))+ l.prior.coeftyp(rj.cursigs[5])\n        })\n                   A<-min(1,exp(num-den))\n                   V<-runif(1)\n                   ifelse(V<=A,{                             # if new model is accepted\n                       rj.cursigs<-rj.newsigs                \n                       curpa<-newpa},\n                                {                            # if model is rejected, reset everything\n                       rj.newsigs<-rj.cursigs\n                       newpa<-curpa\n                                })\n\n\n      # for the state coefficients\n      ifelse(curpa[6]==0,{\n      newpa[6:15]<-1\n      newpara<-which(newpa==1)\n      rj.newsigs[6:15]<-rnorm(10,det.prop.mean[6:15],det.prop.sd[6:15])\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam)) + l.prior.coef(rj.newsigs[6:15])\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + sum(log(dnorm(rj.newsigs[6:15],msyt.prop.mean[6:15],msyt.prop.sd[6:15])))\n        } ,\n        {\n      newpa[6:15]<-0\n      rj.newsigs[6:15]<-0\n      num<-log.lik.fct(c(rj.newsigs,rj.curparam))+ sum(log(dnorm(rj.cursigs[6:15],msyt.prop.mean[6:15],msyt.prop.sd[6:15])))\n      den<-log.lik.fct(c(rj.cursigs,rj.curparam))+ l.prior.coef(rj.cursigs[6:15])\n        })\n        den<-den.l+den.pro\n        num<-num.l+num.pro\n\n                   A<-min(1,exp(num-den))\n                   V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.cursigs<-rj.newsigs               \n                       curpara<-newpara\n                       curpa<-newpa},\n                                {                             \n                       rj.newsigs<-rj.cursigs\n                       newpara<-curpara\n                       newpa<-curpa\n                                })\n\n      # which model did we end up with \n      cur.dmod<-match.function(curpa,det.list)\n# record the model selection for the det fct in det.model for the i'th iteration\ndet.model[i]<-cur.dmod\n\n#################### RJ step for density model ##################################\n      rj.newparam<-rj.curparam\n      # the current model:\n      cur.mod<-count.model[i-1]\n      # the parameters in the current model\n      cur.par<-count.list[cur.mod,]\n      new.par<-cur.par\n\n      # for the year coefficient\n      ifelse (cur.par[3]==0,                                    # if year is not in current model, propose to add it\n                 {new.par[3:4]<-1\n                  # obtain a parameter value from the proposal distribution\n                  rj.newparam[3:4]<-rnorm(2,count.prop.mean[3:4],count.prop.sd[3:4])\n                    # test which model is better\n                    # the numerator of eqn (11)\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + l.prior.year(rj.newparam[3:4]) \n                    # the denominator of eqn (11)\n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + sum(log(dnorm(rj.newparam[3:4],count.prop.mean[3:4],count.prop.sd[3:4])))\n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 } ,\n                 {\n                  rj.newparam[3:4]<-0                            # if year is in the current model, propose to delete it\n                  new.par[3:4]<-0\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam))  + sum(log(dnorm(rj.curparam[3:4],count.prop.mean[3:4],count.prop.sd[3:4])))\n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam))  + l.prior.year(rj.curparam[3:4]) #+ sum(log(dnorm(rj.newparam[new.p],count.prop.mean[new.p],count.prop.sd[new.p])))\n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam              \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 } )\n  # the type coefficient\n              ifelse(cur.par[5]==0,                              # if type is not in current model, propose to add it\n                 {new.par[5]<-1\n                  rj.newparam[5]<-rnorm(1,count.prop.mean[5],count.prop.sd[5])\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + l.prior.type(rj.newparam[5]) \n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam))  + sum(log(dnorm(rj.newparam[5],count.prop.mean[5],count.prop.sd[5])))\n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 } ,\n                 {\n                  rj.newparam[5]<-0                              # if type is in the current model, propose to delete it\n                  new.par[5]<-0\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam))  + sum(log(dnorm(rj.curparam[5],count.prop.mean[5],count.prop.sd[5])))\n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + l.prior.type(rj.curparam[5]) \n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 }  )\n  # the day coefficient\n              ifelse(cur.par[6]==0,                              # if Julian day is not in the current model, propose to add it\n                 {new.par[6]<-1\n                  rj.newparam[6]<-rnorm(1,count.prop.mean[6],count.prop.sd[6])\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + l.prior.day(rj.newparam[6]) \n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + sum(log(dnorm(rj.newparam[6],count.prop.mean[6],count.prop.sd[6])))\n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                            \n                       rj.curparam<-rj.newparam              \n                       cur.par<-new.par},\n                                {                            \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 }  ,\n                 {\n                  rj.newparam[6]<-0                              # if Julian day is in the current model, propose to delete it\n                  new.par[6]<-0\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + sum(log(dnorm(rj.curparam[6],count.prop.mean[6],count.prop.sd[6])))\n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + l.prior.day(rj.curparam[6]) \n                    A<-min(1,exp(num-den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 } )\n  # the state coefficient\n              ifelse(cur.par[8]==0,                             # if state is not in the current model, propose to add it\n                 {new.par[8:17]<-1\n                  for (f in 8:17){\n                  rj.newparam[f]<-rnorm(1,count.prop.mean[f],count.prop.sd[f])}\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + l.prior.st(rj.newparam[8:17]) \n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + sum(log(dnorm(rj.newparam[8:17],count.prop.mean[8:17],count.prop.sd[8:17])))\n                    A<-min(1,exp(rjc.num-rjc.den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 } ,\n                 {\n                  rj.newparam[8:17]<-0                          # if state is in the current model, propose to delete it\n                  new.par[8:17]<-0\n                    num<-log.lik.fct(c(rj.cursigs,rj.newparam)) + sum(log(dnorm(rj.curparam[8:17],count.prop.mean[8:17],count.prop.sd[8:17])))\n                    den<-log.lik.fct(c(rj.cursigs,rj.curparam)) + l.prior.st(rj.curparam[8:17]) \n                    A<-min(1,exp(rjc.num-rjc.den))\n                    V<-runif(1)\n                    ifelse(V<=A,{                             \n                       rj.curparam<-rj.newparam               \n                       cur.par<-new.par},\n                                {                             \n                       rj.newparam<-rj.curparam\n                       new.par<-cur.par\n                                })\n                 }  )\n# which model did we end up with:\ncur.mod<-match.function(cur.par,count.list)\ncount.model[i]<-cur.mod\n\n########################## Metropolis Hastings update ########################################################\n\n########## updating the detection function parameters\nmh.newsigs<-rj.cursigs\nmh.cursigs<-rj.cursigs\n\n              # for scale intercept\n              u<-rnorm(1,0,3.5)                \n              if((mh.cursigs[1]+u)>1){         # prevents scale intercept to become < 0\n              mh.newsigs[1]<-mh.cursigs[1]+u\n              # the numerator of eqn (8)\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.sig(mh.newsigs[1])\n              # the denominator of eqn (8)\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.sig(mh.cursigs[1])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)    }\n              # for shape                  \n              u<-rnorm(1,0,0.2)\n              mh.newsigs[2]<-mh.cursigs[2]+u\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.sha(mh.newsigs[2])\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.sha(mh.cursigs[2])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)\n\n              # for the year coefficients in the scale parameter: levels 2006 and 2007\n              if(mh.cursigs[3]!=0){\n              u<-rnorm(1,0,0.12)\n              mh.newsigs[3]<-mh.cursigs[3]+u\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.coef(mh.newsigs[3])\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.coef(mh.cursigs[3])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)\n\n              u<-rnorm(1,0,0.12)\n              mh.newsigs[4]<-mh.cursigs[4]+u\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.coef(mh.newsigs[4])\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.coef(mh.cursigs[4])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)\n                                 }\n              # for the type coefficient in the scale parameter: level CONTROL\n              if(mh.cursigs[5]!=0){\n              u<-rnorm(1,0,0.12)\n              mh.newsigs[5]<-mh.cursigs[5]+u\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.coeftyp(mh.newsigs[5])\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.coeftyp(mh.cursigs[5])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)\n                                 }\n\n              # for the state coefficients in the scale parameter:\n              if(mh.cursigs[6]!=0){\n              for (ip in 6:15){\n              #u<-rnorm(1,0,0.01)          # acc prob = 80-95%\n              u<-rnorm(1,0,0.12)\n              mh.newsigs[ip]<-mh.cursigs[ip]+u\n              num<-log.lik.fct(c(mh.newsigs,rj.curparam)) + l.prior.coef(mh.newsigs[ip])\n              den<-log.lik.fct(c(mh.cursigs,rj.curparam)) + l.prior.coef(mh.cursigs[ip])\n    A<-min(1,exp(num-den))\n    V<-runif(1)\n    ifelse(V<=A,mh.cursigs<-mh.newsigs,mh.newsigs<-mh.cursigs)\n    }\n                                 }\n    # fill in the new parameter values\n    det.param[i,]<-mh.cursigs\n    rj.cursigs<-mh.cursigs\n\n######### updating the density model parameters\n    curparam<-rj.curparam\n    newparam<-rj.curparam\n\n    # the intercept\n               {u<-rnorm(1,0,0.08)                        \n               newparam[1]<-curparam[1]+u\n               num<-log.lik.fct(newparam) + l.prior.int(newparam[1])\n               den<-log.lik.fct(curparam) + l.prior.int(curparam[1])\n               A<-min(1,exp(num-den))\n               V<-runif(1)\n               ifelse(V<=A,curparam[1]<-newparam[1],newparam[1]<-curparam[1])\n               }\n    # the year coefficients:           \n              if(curparam[3]!=0){\n                       for (m in 3:4){\n                       u<-rnorm(1,0,0.1)\n                       newparam[m]<-curparam[m]+u\n                       num<-log.lik.fct(c(rj.cursigs,newparam)) + l.prior.year1(newparam[m])\n                       den<-log.lik.fct(c(rj.cursigs,curparam)) + l.prior.year1(curparam[m])\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[m]<-newparam[m],newparam[m]<-curparam[m])\n                       }}\n    # the type coefficient\n              if(curparam[5]!=0){\n                       u<-rnorm(1,0,0.06)\n                       newparam[5]<-curparam[5]+u\n                       num<-log.lik.fct(c(rj.cursigs,newparam)) + l.prior.type(newparam[5])\n                       den<-log.lik.fct(c(rj.cursigs,curparam)) + l.prior.type(curparam[5])\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[5]<-newparam[5],newparam[5]<-curparam[5])\n                       }\n    # day coefficient\n              if(curparam[6]!=0){\n                       u<-rnorm(1,0,0.02)\n                       newparam[6]<-curparam[6]+u\n                       num<-log.lik.fct(c(rj.cursigs,newparam))    + l.prior.day(newparam[6])\n                       den<-log.lik.fct(c(rj.cursigs,curparam))    + l.prior.day(curparam[6])\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[6]<-newparam[6],newparam[6]<-curparam[6])\n                       }\n    # the state coefficients \n              ifelse(curparam[8]==0){\n              for (m in 8:17){\n                       u<-rnorm(1,0,0.25)\n                       newparam[m]<-curparam[m]+u\n                       num<-log.lik.fct(c(rj.cursigs,newparam))    + l.prior.1st(newparam[m])\n                       den<-log.lik.fct(c(rj.cursigs,curparam))    + l.prior.1st(curparam[m])\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[m]<-newparam[m],newparam[m]<-curparam[m])\n              } }  \n    # the random effect standard deviation\n              {u<-max(rnorm(1,0,0.08),-newparam[18])    # cannot become 0 or less\n              newparam[18]<-curparam[18]+u\n              num<-log.ran.fct(c(rj.cursigs,newparam))    + l.prior.std.ran(newparam[18])\n              den<-log.ran.fct(c(rj.cursigs,curparam))    + l.prior.std.ran(curparam[18])\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[18]<-newparam[18],newparam[18]<-curparam[18])\n              }\n    # the random effects coefficients\n    for (m in 19:(j+18)){\n              u<-rnorm(1,0,0.4)\n              newparam[m]<-curparam[m]+u\n              num<-log.lik.fct(c(rj.cursigs,newparam))\n              den<-log.lik.fct(c(rj.cursigs,curparam))\n              A<-min(1,exp(num-den))\n              V<-runif(1)\n              ifelse(V<=A,curparam[m]<-newparam[m],newparam[m]<-curparam[m])\n              }\n\n    # saving the new parameter values of the density model in count.param\n    count.param[i,]<-curparam[1:(j+18)]\n\n    rj.curparam<-curparam\n    rj.newparam<-curparam\n  # saving the parameter matrices ever 1000 iterations\n  if(!is.na(match(i,seq(0,200000,1000))==T)){\n  save(det.model,file='det.model.RData')\n  save(count.model,file='count.model.RData')\n  save(det.param,file='msyt.param.RData')\n  save(count.param,file='count.param.RData')\n  }\n  \n  } # end of iteration\n\n\n\n###### Alterations to this algorithm: \n# dis = distance (perpendicular for lines and radial for points, sigma = scale parameters, shape = shape parameter\n\n# using a half-normal detection function for point transects for f(y); \\pi(y) * g(y|\\bmath{\\theta}) from eqn (2) is given by\nf.hn.function<-function(dis,sigma){\n  f <- 2*pi*dis*exp(-dis^2/(2*sigma^2))\n  return(f)\n  }\n\n# using a half-normal detection function for line transects for f*y); g(y|\\bmath{\\theta}) from eqn (2) is given by (\\pi(y) can be ommitted for line transects)\nf.hn.function <- function(dis,sigma) {\n  f <- exp(-dis^2/(2*sigma^2))\n  f\n}\n\n# using a hazard-rate function for point transects for f(y); \\pi(y) * g(y|\\bmath{\\theta}) from eqn (2) is given by\nf.haz.function<-function(dis,sigma,shape) {\n  f <- 2*pi*dis*(1-exp(-(dis/sigma)^(-shape)))\n  return(f)\n  }\n\n# using a hazard-rate function for line transects for f(y); g(y|\\bmath{\\theta}) from eqn (2) is given by (\\pi(y) can be ommitted for line transects)\nf.haz.function<-function(dis,sigma,shape) {\n  f <- 1-exp(-(dis/sigma)^(-shape))\n  return(f)\n  }\n\n# interval distance data: \n# the fi's for interval data using half-normal detection function for lines or points\n# requires defining cutpoints for the intervals and the truncation distance w\nf.haz.int<-function(cutpoint1,cutpoint2,sigma,shape){\n norm.const<-integrate(f.hn.function,0,w,sigma)$value\n int.prob<-integrate(f.haz.function,cutpoint1,cutpoint2,sigma,shape)$value/norm.const\n return(int.prob)\n }\n\n# the fi's for interval data using hazard-rate detection function for lines or points\n# requires defining cutpoints for the intervals and the truncation distance w\nf.haz.int<-function(cutpoint1,cutpoint2,sigma,shape){\n norm.const<-integrate(f.haz.function,0,w,sigma,shape)$value\n int.prob<-integrate(f.haz.function,cutpoint1,cutpoint2,sigma,shape)$value/norm.const\n return(int.prob)\n }\n",
    "created" : 1423503720353.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3715555077",
    "id" : "A67F118B",
    "lastKnownWriteTime" : 1423503714,
    "path" : "~/Downloads/CarryOver_effects/13253_2014_167_MOESM1_ESM(1).r",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}