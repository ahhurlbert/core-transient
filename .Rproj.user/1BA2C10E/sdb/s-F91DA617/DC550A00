{
    "contents" : "###################################################################################*\n# CORE-TRANSIENT FUNCTIONS                                                         *\n###################################################################################*\n# This script contains all of the functions used in the analyses that summarize\n# core-transient data by site (and across sites). It is divided in 3 parts:\n#   1. Bimodality summary statistics\n#   2. Summary output tables for a given site and across sites\n#   3. Plot output\n\n#==================================================================================*\n# ---- LOAD LIBRARIES ----\n#==================================================================================*\n\n# Load libraries:\n\nlibrary(plyr)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\nlibrary(MASS)\n\n#==================================================================================*\n# ---- GENERAL FUNCTIONS ----\n#==================================================================================*\n\n# Standard error:\n\nse = function(x) sd(x)/sqrt(length(x))\n\n#==================================================================================*\n# ---- FUNCTIONS for proportional occurrence and site summary data frames  ----\n#==================================================================================*\n\n# Function to change date object to year:\n\ngetYear = function(date){\n  if (class(date)[1] == 'factor') date = as.POSIXlt(date)\n  return(as.numeric(format(date, '%Y')))\n}\n\n# The following function is used to create and explore and extract the species \n# richness and number of time samples for a site.\n\nsiteSummaryFun = function(dataset){\n  ddply(dataset, .(datasetID, site), summarize, \n        spRich = length(unique(species)), \n        nTime = length(unique(year)))\n}\n\n# The following function writes the proportional occurence data\n# frame on sites.\n\npropOccFun = function(dataset){\n  spTime = ddply(dataset, .(datasetID, site, species), summarize, \n                 spTime = length(unique(year)))\n  siteTime = ddply(dataset, .(datasetID, site), summarize, \n                   siteTime = length(unique(year)))\n  propOcc = merge(spTime, siteTime)\n  propOcc$propOcc = propOcc$spTime / propOcc$siteTime\n  return(propOcc[,-c(4:5)])\n}\n\n#==================================================================================*\n# ---- GET DATA ----\n#==================================================================================*\n\n# The following function reads in the data and returns a list of the proportional \n# occurence data frame, the site summary (sp richness and number of time samples\n# for a given site), system, and taxa:\n\ngetDataList = function(datasetID){\n  propOcc = read.csv(paste('data/propOcc_datasets/propOcc_', \n                           datasetID, '.csv', sep = ''))\n  siteSummary = read.csv(paste('data/siteSummaries/siteSummary_', \n                               datasetID, '.csv',  sep = ''))\n  metaData = subset(read.csv('data_source_table.csv'),\n                    dataset_ID == datasetID)\n  system = metaData$system\n  taxa = metaData$taxa\n  return(list(propOcc = propOcc, siteSummary = siteSummary, \n              system = system, taxa = taxa))\n}\n\n#==================================================================================*\n# ---- BIMODALILITY ----\n#==================================================================================*\n# NOTE: For these functions to run, occProp, Ntime, and outSummary frames must\n# already be loaded and the \"Sampling summary\" lines of code MUST be run in the \n# dashboard!\n#\n# Functions:\n# - bimodality: Calculates the bimodality metric developed by Allen and Ethan. \n#     Inputs: Site\n#     Outputs: A single numeric bimodality value\n#\n# - random.bimodality: The bimodality for a random sample of the dataset.\n#     Inputs: Site\n#     Outputs: A single numeric bimodality value\n#\n# - p.bimodal: Randomization test for bimodality. Runs n-reps of the random.\n#     bimodality function and compares the actual bimodality with the \n#     distribution of random values.\n#     Inputs: Site, number of reps\n#     Outputs: A single numeric p-value.\n#\n# - occs.scaled: Scales occupancy from [0,1] to (0,1) -- because beta distribution\n#     inputs must not contain 0's or 1's.\n#     Inputs: Site\n#     Outputs: A numeric vector of scaled occupancy values.\n# \n# - fitbeta: Calculates the shape parameters for a fitted beta distribution.\n#     Inputs: Site\n#     Outputs: A vector of shape parameters (alpha and beta).\n# \n#----------------------------------------------------------------------------------*\n# ---- Function for calculating bimodality ----\n#==================================================================================*\n# Note 1: Bimodality is the fraction of species occurring at either end of \n# occupancy distribution. We use a randomization approach to test whether the \n# distribution is significantly bimodal.\n# Note 2: To run this function the number of time samples for the site (nt) needs\n# to be specified. This is done so in the wrapper summary table function.\n\n\nbimodalityFun = function(propOcc_or_RandomPropOcc, nTime){\n  occs = propOcc_or_RandomPropOcc\n  maxvar = var(c(rep(1/nTime,floor(length(occs)/2)),\n                 rep(1,ceiling(length(occs)/2))))\n  return(var(occs)/maxvar)\n}\n\n# Random sample of occurences for a given site (to be used in randomization, below):\n\nrandomOccsFun = function(propOcc, nTime){\n  # Generate a table (data frame) of occProps and frequencies:\n  occPropTable = data.frame(table(propOcc))\n  # Create a data frame of possible occProps:\n  occPropDummyTable = data.frame(propOcc = seq(1/nTime, 1, by = 1/nTime))\n  # Merge the two data frames:\n  combinedTable = merge(occPropDummyTable, occPropTable, all.x = T)\n  combinedTable[is.na(combinedTable[,2]),2]<-0                            # Replace NA's with zeros\n  # Reassign bin values randomly and add to frame:\n  newFreq = sample(combinedTable$Freq, length(combinedTable[,1]))\n  randomTable = data.frame(combinedTable[,1], newFreq)\n  randomOccs=unlist(apply(randomTable, 1, function(x) rep(x[1], x[2])))\n  return(as.vector(randomOccs))\n}\n\n# Randomization test for bimodality:\n\npBimodalFun = function(propOcc,nTime, reps){\n  actualBimod = bimodalityFun(propOcc, nTime)\n  # For loop to get random bimodality values\n  randomBimod = numeric(length = reps)\n  for (i in 1:reps){\n    randomBimod[i] = bimodalityFun(randomOccsFun(propOcc, nTime), nTime)\n  }\n  # Calculate the p-value (proportion of sites with higher bimodality than the\n  # actual bimodality value):\n  sum(randomBimod >= actualBimod)/(reps + 1)\n}\n\n#----------------------------------------------------------------------------------*\n# ---- Function for fitting the beta distribution ----\n#==================================================================================*\n# Required packages = MASS\n\n# Scale occupancy from [0,1] to (0,1) following Smithson and Verkuilen 2006\n# Note: See supplemental at\n# http://supp.apa.org/psycarticles/supplemental/met_11_1_54/met_11_1_54_supp.html\n\noccsScaledFun = function(occProp){\n  x = occProp# [as.character(occProp$site) == site,'occ']\n  n = length(x)\n  s = .5\n  (x*(n-1)+s)/n\n}\n\n# Fit beta distribution:\n\nfitBeta = function(occProp) {\n  if (bimodalityFun(occProp,nTime)!= 0)\n  {occs  = occsScaledFun(occProp)\n  shape.params = suppressWarnings(fitdistr(occs, \"beta\",\n                                  list(shape1 = 2, shape2 = 2)))\n  return(as.vector(shape.params$estimate))\n  } else c(NA, NA)\n}\n\n#==================================================================================*\n# ---- CORE-TRANSIENT MODE STATISTICS ----\n#==================================================================================*\n\n# Proportion of samples that are core or transient:\n\nmodeProp = function(propOcc, mode, threshold) {\n  if (mode == 'core') length(propOcc[propOcc >= 1-propOcc])/length(propOcc)\n    else length(propOcc[propOcc <= threshold])/length(propOcc)\n}\n\n# Randomization test for a given mode (is the proportion of samples in core or\n# transient greater than we would expect by random chance):\n\npModeFun = function(propOcc, nTime, mode, threshold, reps){\n    actualProp = modeProp(propOcc, mode, threshold)\n  # For loop to get random frequncies in the mode:\n    randomProps = numeric(length = reps)\n    for (i in 1:reps){\n      randomProps[i] = modeProp(randomOccsFun(propOcc, nTime), mode, threshold)\n    }\n  # Calculate the p-value (proportion of sites with higher frequency than the\n  # actual bimodality value):\n  pVal = sum(randomProps >= actualProp)/(reps + 1)\n  return(pVal)\n}\n\n#==================================================================================*\n# ---- DATASET SUMMARY FUNCTIONS ----\n#==================================================================================*\n# NOTE: For these functions to run, occProp, Ntime, and outSummary frames must\n# already be loaded!\n#\n# Functions:\n# - summaryStats: Produces summary sampling data for one site. \n#     Inputs: Site and the threshold value for core and transient designation.\n#     Outputs: A one-row dataframe with dataset ID, site ID, threshold used,\n#       the system, taxa, # of time samples, total, core, and transient richness\n#       proportion of core and transient species, and the average proportion of \n#       occurance across species.\n#\n# - ctSummary: A partial-wrapper function that runs and compiles bimodality test\n#     statistics across sites and adds it to the sampling summary frame above.\n#     Inputs: Site and the threshold value for core and transient designation.\n#     Outputs: A one-row dataframe with the summary output above and bimodality\n#     (Allen + Ethan formula), randomization-derived p-value, and the alpha and\n#     beta shape parameters for the beta distibution.\n#\n#----------------------------------------------------------------------------------*\n# ---- Function to generate summary of sampling ----\n#==================================================================================*\n\n# Summary stats for all sites in a dataset:\n\nsummaryStatsFun = function(datasetID, threshold, reps){\n  # Get data:\n  dataList = getDataList(datasetID)\n  sites  = dataList$siteSummary$site\n  # Get summary stats for each site:\n  outList = list(length = length(sites))\n  for(i in 1:length(sites)){\n    propOcc = subset(dataList$propOcc, site == sites[i])$propOcc\n    siteSummary = subset(dataList$siteSummary, site == sites[i])\n    nTime = siteSummary$nTime\n    spRichTotal = siteSummary$spRich\n    spRichCore = length(propOcc[propOcc >= 1 - threshold])\n    spRichTrans = length(propOcc[propOcc <= threshold])\n    propCore = spRichCore/spRichTotal\n    propCore_pVal = pModeFun(propOcc, nTime, 'core', threshold, reps)\n    propTrans = spRichTrans/spRichTotal\n    propTrans_pVal = pModeFun(propOcc, nTime, 'trans', threshold, reps)\n    mu = mean(propOcc)\n    bimodality = bimodalityFun(propOcc, nTime)\n    pBimodal = pBimodalFun(propOcc, nTime, reps)\n    outList[[i]] = data.frame(datasetID, site = sites[i],\n                              system = dataList$system, taxa = dataList$taxa,\n                              nTime, spRichTotal, spRichCore, spRichTrans,\n                              propCore, propCore_pVal,  propTrans, propTrans_pVal,\n                              mu, bimodality, pBimodal)\n  }\n  return(rbind.fill(outList))\n}\n\n###################################################################################*\n# ---- UPDATE COMPLETE TO THIS POINT ----\n###################################################################################*\n\n#==================================================================================*\n# ---- PLOT FUNCTIONS ----\n#==================================================================================*\n# NOTE: For these functions to run, occProp, Ntime, and outSummary frames must\n# already be loaded!\n\n#----------------------------------------------------------------------------------*\n# ---- Custom themes ----\n#==================================================================================*\n\n# Theme for plot with no background grid:\n\ntheme_CT_NoGrid = function(base_size = 12) {\n  theme(\n    axis.text.x = element_text(size=14, color = 'black',vjust = 1, hjust = .5),\n    axis.text.y = element_text(size=12, color = 'black', hjust = 1),\n    axis.title.x = element_text(size = 18, vjust = -1),\n    axis.title.y = element_text(size = 18, vjust = 1.5),\n    title = element_text(size=16, vjust = 1),\n    legend.title=element_blank(),\n    axis.line = element_line(color = 'black'),\n    panel.background = element_blank(),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.margin = unit(c(2,.5,1.5,.5), 'lines'))\n}\n\ntheme_CT_Grid = function(base_size = 12) {\n  theme(axis.text = element_text(size=14, color = 'black'),\n        axis.title.x = element_text(size = 18, vjust = -1),\n        axis.title.y = element_text(size = 18, vjust = 1),\n        title = element_text(size=18, vjust = -0.5),\n        axis.line = element_line(colour = 'black'),\n        panel.background = element_blank(),\n        panel.grid.major = element_line(size = .5, color = 'gray90'),\n        panel.grid.minor = element_line(size = .25, color = 'gray90'),\n        plot.margin = unit(c(0,.5,1.5,.5), 'lines'))\n}\n\n#----------------------------------------------------------------------------------*\n# ---- Function to make core-transient histogram  ----\n#==================================================================================*\n# This function creates a ct histogram for one site:\n\nct.hist = function(site) {\n  # Get data, subset to a given site:\n      occProp = occProp[as.character(occProp$site) == site,]\n      ct = ct[as.character(ct$site) == site, ]\n  # Plot labels:\n    main = paste('Site ', site, paste('(',  as.character(ct$system),\n                   ', ', as.character(ct$taxa),')', sep = ''))\n    sub = bquote(b ~ '=' ~ .(round(ct$bimodal, 2)) ~ '    '~\n                   P['b'] ~ '=' ~ .(round(ct$bimodal.p, 3)) ~ '    '~\n                   mu ~ '=' ~ .(round(ct$mu, 2)) ~ '    '~\n                   t ~ '=' ~ .(ct$nTime))\n    sub2 = bquote(alpha ~ '=' ~ .(round(ct$alpha, 3)) ~ '    '~\n                   beta ~ '=' ~ .(round(ct$beta, 3)))\n  # Set band width, breaks and possible values of x for the histogram:\n    bw = 1/nTime#(max(occProp$occ)-min(occProp$occ))/10\n    brks = seq(min(occProp$occ), max(occProp$occ),bw)\n    x = seq(1/ct$nTime,1-1/ct$nTime, .01)\n    beta.df = data.frame(x = x, y = dbeta(x, ct$alpha, ct$beta))\n  # Plot data: \n    out.plot = ggplot(occProp, aes(x=occ)) +\n      geom_histogram(aes(y = ..density..), binwidth = bw, breaks = brks, right = F,\n                     fill = 'gray', color = 1) +\n      xlim(1/nTime, 1) +\n      geom_line(data = beta.df, aes(x = x, y = y), color = 'red') +\n      # stat_function(fun = function(x) dbeta(x, ct$alpha, ct$beta), color = 'red') +\n      # Add labels:\n      xlab('Proportion of temporal samples') + ylab('Density') + \n      ggtitle(bquote(atop(.(main), atop(.(sub), atop(.(sub2)))))) +\n      # Add themes:\n      theme(axis.text = element_text(size=14, color = 1),\n            axis.title.x = element_text(vjust = -1),\n            axis.title.y = element_text(vjust = 2),\n            title = element_text(size=16, vjust = -1),\n            axis.line = element_line(colour = \"black\"),\n            panel.background = element_blank(),\n            plot.margin = unit(c(.5,.5,1.5,1), \"lines\"))\n    return(out.plot)\n  }\n",
    "created" : 1425316948525.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1019241753",
    "id" : "DC550A00",
    "lastKnownWriteTime" : 1425326621,
    "path" : "~/core-transient/scripts/R-scripts/core-transient_functions.R",
    "project_path" : "scripts/R-scripts/core-transient_functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}